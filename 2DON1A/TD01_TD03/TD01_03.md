## TD2 – Projection - Sélection

SELECT - affiche des données d’une base de données relationnelle

```

SELECT liste d’expressions
FROM table(s)
WHERE conditions sur les lignes

```

Grâce à ces commandes SQL on les table de ce schéma pour Oracle Apex.

![Schéma de la base](schema.png)

```

CREATE TABLE client (
ncli VARCHAR2(10) NOT NULL,
nom VARCHAR2(32),
adresse VARCHAR2(32),
localite VARCHAR2(30),
cat CHAR(2),
compte NUMBER(9,2),
CONSTRAINT pk_client PRIMARY KEY (ncli),
CONSTRAINT ck_client_cat CHECK (cat IN ('0','1'))
);

CREATE TABLE produit (
npro VARCHAR2(15) NOT NULL,
libelle VARCHAR2(60),
prix NUMBER(8,2),
qstock NUMBER(8),
CONSTRAINT pk_produit PRIMARY KEY (npro)
);

CREATE TABLE commande (
ncom NUMBER(12) NOT NULL,
ncli VARCHAR2(10) NOT NULL,
datecom DATE,
CONSTRAINT pk_commande PRIMARY KEY (ncom),
CONSTRAINT fk_commande_client FOREIGN KEY (ncli)
REFERENCES client (ncli)
);

CREATE TABLE detail (
ncom NUMBER(12) NOT NULL,
npro VARCHAR2(15) NOT NULL,
qcom NUMBER(8),
CONSTRAINT pk_detail PRIMARY KEY (ncom, npro),
CONSTRAINT fk_detail_commande FOREIGN KEY (ncom)
REFERENCES commande (ncom),
CONSTRAINT fk_detail_produit FOREIGN KEY (npro)
REFERENCES produit (npro)
);
```

#### Afficher des données => SELECT

SELECT = Afficher

- = All (tout)

Nom de la Table

Donc, nous avons afficher toutes les données de la table Produit.

```
SELECT * FROM Product

```

**_Distinct_**

Permet de retirer les doublons.

Se met directement derrière SELECT, comme suit:

```

SELECT DISTINCT * FROM Produit;

```

Remarque:

Sur Apex, les tables seront représentées par leur nom préfixé de "esi". Pour les SGBDR Oracle, nousdevons préfixer les noms des tables par le nom du propriétaire des tables. Sur Apex les tables de cette base de données appartiennent à "esi",

**_Les conditions _**

AND , OR , NOT sont les opérateurs logiques.

= , !=, <, >, <=, >= , sont les opérateurs de comparaisons.

% est utilisé par l'opérateur LIKE en vue de rechercher un pattern dans un attribut.

BETWEEN est l'opérateur qui permet de sélectionner des valeurs entre deux bornes incluses.

IN est l'opérateur qui permet d'écrire plus simplement plusieurs conditions OR.

#### Exercices:

Question 2:

Afficher le libellé et le prix de tous les produits.

```
SELECT LIBELLE, PRIX from Produit;

```

Question 3:

Afficher le libellé et le prix de tous les produits qui coûtent plus de 200 euros.

```
SELECT Prix
FROM Produit
WHERE Prix > 200;

```

Question 4:

Afficher le numéro, le nom et la localité des clients de catégorie C1 n’habitant pas à Toulouse.

```
SELECT Ncli, Nom, Localite
FROM Client
WHERE Cat = 1
AND Localite !='Toulouse';

```

Autre possibilité:

```
SELECT Ncli, Nom, Localite
FROM Client
WHERE Cat = 1
AND Localite <> 'Toulouse';

```

Remarque:

En SQL on met le WHERE qu'une seule fois.

Question 5:

Afficher tous les attributs des produit dont le libellé contient le mot “ACIER”.

```
SELECT * FROM Produit
WHERE Libelle LIKE '%Acier%';

```

Question 6:

Afficher la liste des localités dans lesquelles il existe au moins un client (sans doublons).

```
SELECT DISTINCT Localite
FROM Client;

```

Question 7:

Quelles sont les catégories des clients qui habitent à Toulouse ?

```
SELECT Cat FROM Client
WHERE Localite = 'Toulouse';

```

Question 8:

Afficher la liste des produits (numéro et libellé) dont le prix est compris entre 100 et 150 euros, bornes comprises.

```
SELECT Npro, Libelle FROM Produit
WHERE Prix BETWEEN 100 AND 150;

```

Remarque:

Avec BETWEEN les bornes sont incluses. Pour les exclure:

```
SELECT Npro, Libelle FROM Produit
WHERE Prix >= 100 AND Prix <= 150;

```

Attention:

Il faut bien mettre le le signe plus grand ou plus petit AVANT le signe égal.

Pour exclure une borne et pas l'autre.

```
SELECT Npro, Libelle FROM Produit
WHERE Prix >= 100 AND Prix < 150;

```

Question 9:

Afficher la liste des produits (numéro et libellé) dont le prix est compris entre 100 et 150 euros, bornes exclues

```
SELECT Libelle, npro FROM Produit
WHERE PRIX > 100 AND Prix < 150;

```

Question 10:

Donner le numéro, le nom et le compte des clients de Poitiers et de Bruxelles dont le compte est (strictement) positif.

```
SELECT Ncli, Nom, Compte FROM Client
WHERE Localite IN ('Poitiers', 'Bruxelles')
AND Compte > 0;

```

Question 11:

Afficher le numéro, le nom et la localité des clients dont le nom précède alphabétiquement la localité où ils résident.

```
SELECT nCli, Nom, Localite FROM Client
WHERE Nom < Localite;

```

Remarque:

Ici on ne consièdre pas toutes les lettres, mais seulement la première.

Question 12:

Afficher les clients habitant à Lille ou à Namur.

```
SELECT * FROM Client
WHERE Localite iN ('Lille', 'Namur');

```

Remarque:
Quand on ne précise pas les tables à afficher on les affiche toutes avec " \* ".

Question 13:

Afficher les clients qui n’habitent ni à Lille ni à Namur.

```
SELECT * FROM Client
WHERE Localite != 'Lille' AND Localite != 'Namur';

```

Question 14:

Afficher les clients de catégorie C1 habitant à Namur.

```

SELECT * FROM Client
WHERE Cat='C1' AND Localite ='Namur';

```

Question 15:

Afficher les clients qui sont de catégorie C1 ou qui habitent à Namur.

```
SELECT * FROM Client
WHERE Cat='C1' OR Localite ='Namur';

```

Question 16:

Afficher les clients de catégorie C1 n’habitant pas à Namur.

```
SELECT * FROM Client
WHERE Cat='C1' AND Localite !='Namur';

```

Question 17:

Afficher les clients qui ne sont pas de catégorie C1 ou qui sont de Namur.

```
SELECT * FROM Client
WHERE Cat!='C1' OR Localite ='Namur';
```

Question 18:

Afficher les clients qui soit sont de catégorie B1 ou C1, soit habitent à Lille ou à Namur (ou les deux conditions).

```
SELECT *
FROM Client
WHERE Cat IN ('B1', 'C1')
   OR Localite IN ('Lille', 'Namur');

```

Question 19:

Afficher les clients qui soit sont de catégorie B1 ou C1, soit habitent à Lille ou à Namur (mais pas les deux conditions).

```
SELECT *
FROM Client
WHERE (Cat IN ('B1', 'C1') AND Localite NOT IN ('Lille', 'Namur'))
   OR (Cat NOT IN ('B1', 'C1') AND Localite IN ('Lille', 'Namur'));

```

Remarque:

Ici, nous avons les 2 ensembles A et B tel que A = (Cat IN ('B1', 'C1')) et B= (Localite IN ('Lille', 'Namur')). Et les complément respectives de A et B sont ¬A = (Cat NOT IN ('B1', 'C1')) et ¬B = (Localite NOT IN ('Lille', 'Namur')).

L'enoncé veut le OU EXCLUSIF. Voir cours de Math discrètes sur les ensembles.

A XOR B = A⊕B=(A∧¬B)∨(¬A∧B)

Question 20:

Afficher les clients qui sont de catégorie B1 ou C1, et qui habitent à Lille ou à Namur.

```
SELECT *
FROM Client
WHERE Cat IN ('B1', 'C1') AND Localite IN ('Lille', 'Namur');

```

Question 21:

Afficher les clients qui ne sont ni de catégorie B1 ni C1, et qui n’habitent ni Lille ni à Namur.

```
SELECT *
FROM Client
WHERE Cat NOT IN ('B1', 'C1')
  AND Localite NOT IN ('Lille', 'Namur');

```

## TD3 – Fonctions

MIN (colonne) donne la plus petite valeur de la colonne sélectionnée

MAX (colonne) ... la plus grande valeur de ...

SUM(Colonne) ... la somme des valeurs de la colonne numériques sélectionnée

AVG (colonne) ... la moyenne des valeurs de la colonne ...

COUNT (colonne) donne le nombre de valeurs non nulles de la colonne sélectionnée

COUNT(\*) donne le nombre total de lignes d’une table, y compris celles dont les valeurs sont NULL

UPPER(chaine) transforme une chaine en majuscule

LOWER(chaine) transforme une chaine en minisucule

chaîne1 || chaîne2 concatène 2 chaines

- , - , \* , / , % sont les opérateurs arithmétiques

---

Question 2:

Afficher le nombre de clients qui ont une catégorie non-nulle (en utilisant un WHERE).

```
SELECT COUNT(*) nCli FROM Client
WHERE Cat IS NOT NULL;

```

---

Question 3:

Afficher le nombre de clients qui ont une catégorie non-nulle (sans utiliser le WHERE ).

```
SELECT COUNT(Cat) AS nCli
FROM Client;

```

COUNT(\*) → compte toutes les lignes

COUNT(Cat) → compte seulement les lignes où Cat n’est pas NULL

Donc cette requête donne exactement le nombre de clients ayant une catégorie non nulle, sans utiliser WHERE.

Question 4:

Afficher le nombre de commandes pour le client "C400".

```
SELECT COUNT(nCli) AS nb_commandes_COO3
FROM Commande
WHERE nCLi = 'C400';

```

---

Question 5:

Afficher le nombre de commandes pour le client "C401".

```
SELECT COUNT(\*) AS nb_commandes_COO3
FROM Commande
WHERE nCLi = 'C400';

```

---

Question 6:

Afficher le nombre de catégories différentes parmi tous les clients.

```

SELECT COUNT(DISTINCT Cat) FROM Client;

```

Si un client apparaît 5 fois → il est compté 1 seule fois

Si un client apparaît 1 fois → il est compté 1 fois

Les valeurs NULL ne sont pas comptées

---

Question 7:

Afficher le nombre de clients qui n’ont pas de catégorie.

```

SELECT COUNT(cat) FROM CLIENT
WHERE CAT IS NOT NULL;

```

---

Question 8:

Afficher le prix du produit le plus cher.

```

SELECT MAX(Prix) FROM Produit;

```

---

Question 9:

Afficher le prix du produit le moins cher.

```

SELECT MIN(Prix) FROM Produit;

```

---

Question 10:

Afficher le prix moyen des produits.

```

SELECT AVG(Prix) FROM Produit;

```

---

Question 11:

Afficher la somme du prix de tous les produits.

```

SELECT SUM(Prix) FROM Produit;

```

---

Question 12:

Afficher la somme du prix de tout le stock de produits.

```

X

```

---

Question 13:

Afficher la date de la plus ancienne commande.

```

SELECT MIN(DateCom) FROM Commande;

```

MAX(DateCom) → retourne la date la plus grande, donc la plus récente

MIN(DateCom) → retourne la plus petite valeur de la colonne DateCom → donc la plus ancienne

---

Question 14:

Afficher la somme, le minimum, la moyenne et le maximum des comptes des clients (sans tenir compte des commandes actuelles).

```

SELECT
SUM(Compte) AS somme_comptes,
MIN(Compte) AS minimum_compte,
AVG(Compte) AS moyenne_compte,
MAX(Compte) AS maximum_compte
FROM Client;

```

En SQL, AS sert à donner un alias à une colonne ou à une table, c’est-à-dire un nom temporaire et lisible pour le résultat.

---

Question 15:

Afficher la somme, le minimum, la moyenne et le maximum des comptes des clients de Toulouse.

```

SELECT
SUM(Compte) AS somme_comptes,
MIN(Compte) AS minimum_compte,
AVG(Compte) AS moyenne_compte,
MAX(Compte) AS maximum_compte
FROM Client;

```

---

Question 16:

Afficher le nom et l’adresse complète (adresse + localité) de tous les clients mais en une seule chaîne de caractères et en majuscules.

```

SELECT Nom,Adresse, Localite FROM Client
WHERE UPPER(Nom) || UPPER(Adresse) || UPPER(Localite);

```

---

Question 17:

Afficher la valeur du stock pour le produit "CS264",suivi de la chaîne "euros".

```

SELECT UPPER(Nom || ' ' || Adresse || ' ' || Localite) AS Chaine FROM Client;

```

Ou

```

SELECT UPPER(Nom || ' ' || Adresse || ' ' || Localite) AS Chaine FROM Client;

```

---

Question 18:

Afficher le nombre de produits proposés par l’entreprise.

```
SELECT COUNT(NPRO) FROM Produit;

```

---

Question 19:

Afficher le nombre de produits différents qui ont été commandés.

```

SELECT COUNT(DISTINCT Npro) FROM Detail;

```

Remarque:

Ici on veut les produits commandés, alors il faut chercher la réponse dans la table détail car on a là les produits commandés. Cette table fait le lien entre la table client et la table produits.
Si on prend la table Produit, on risque de prendre les produits qui ne sont pas encore commandés.

---

Question 20:

Afficher la quantité totale de produits qui ont été commandés.

```
SELECT SUM(Qcom) FROM Detail;

```

...quantité totale de produits => SUM()

---

Question 21:

Afficher le nombre de commandes et la quantité totale commandée pour le produit "CS464".

```

SELECT COUNT(NCOM),SUM(Qcom) FROM Detail
    WHERE Npro = 'CS464';

```

... le nombre de commandes => COUNT()
... la quantité totale commandée =>

---

Question 22:

Afficher le nombre de produits qui coûtent strictement moins de 100 euros.

```
SELECT COUNT(nPRO) FROM Produit
   WHERE Prix <> 100;

```

... le nombre de produits => COUNT()
... strictement moins de 100 euros => WHERE Prix < 100

---

Question 23:

Afficher la liste des numéros et libellés des produits dont la valeur du stock (en euros) est supérieur ou égal à 40 000 et inférieur ou égal à 100000.

```

```
