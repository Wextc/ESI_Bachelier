### Résumé:

![permission_cat](https://github.com/Wextc/ESI_Bachelier/blob/main/DEV1/Laboratoire/TD11/img/resume.png)

<b>Création et accès</b>

l = []

Crée une liste vide.

```
l = []

print(l)            # []

```

l[i]

Retourne l’élément à l’indice i (les indices commencent à 0).

```
# Accéder à un élément par son indice

l = [10, 20, 30]

print(l[0])         # 10

print(l[2])         # 30

```

len(l)

Donne le nombre d’éléments dans la liste.

```

l = [10, 20, 30]

# Longueur de la liste

print(len(l))       # 3


```

x in l

Renvoie True si x est dans la liste, sinon False.

```
l = [10, 20, 30]

# Tester si un élément est dans la liste

print(20 in l)      # True

print(40 in l)      # False


```

<b>Modification</b>

del l[i]

Supprime l’élément à l’indice i.

```
l = [1, 2, 3, 4]

# Supprimer un élément par son indice. On compte 0 posistion pour 1, 1 pour 2 , 3  pour 4. Donc ici c est 2 qui est supprimer.

del l[1]

print(l)            # [1, 3, 4]


```

l[i] = x

Remplace l’élément d’indice i par x.

```
l = [1, 3, 4]

# Modifier un élément. L'élément positionné à 0 qui est remplacé par 10.

l[0] = 10

print(l)            # [10, 3, 4]

```

l.append(x)

Ajoute x à la fin de la liste.

```
l = [10, 3, 4]

# Ajouter un élément à la fin

l.append(5)

print(l)            # [10, 3, 4, 5]


```

l.extend(l1)

Ajoute tous les éléments de l1 à la fin de l.

```
l = [10, 3, 4, 5]

# Ajouter une autre liste

l1 = [6, 7]

l.extend(l1)

print(l)            # [10, 3, 4, 5, 6, 7]

```

l.insert(i, x)

Insère x à l’indice i (décale les autres éléments).

```
l =  [10, 3, 4, 5, 6, 7]

# Insérer un élément à un indice précis

l.insert(2, 99)

print(l)            # [10, 3, 99, 4, 5, 6, 7]

```

<b>Opérations entre listes</b>

l1 + l2

Concatène deux listes.

```

l1 = [1, 2]

l2 = [3, 4]

# Concaténation

l3 = l1 + l2

print(l3)           # [1, 2, 3, 4]

```

l \* 3

Répète la liste 3 fois.

```
l1 = [1, 2]

# Répétition

print(l1 * 3)       # [1, 2, 1, 2, 1, 2]

```

l[i:j]

Slicing : sous-liste de l’indice i inclus à j exclu.

```
l = [10, 20, 30, 40, 50]

# Slicing (sous-liste)

print(l[1:4])       # [20, 30, 40]

```

<b>Recherche et comptage</b>

l.count(x)

Compte le nombre d’occurrences de x.

```
l = [1, 2, 2, 3, 2]

# Compter les occurrences

print(l.count(2))   # 3

# Trouver l’indice de la première occurrence

print(l.index(2))   # 1

```

l.index(x)

Donne l’indice de la première occurrence de x.

```
l = [10, 20, 30, 40]

# Supprimer et récupérer le dernier élément

x = l.pop()

print(x)            # 40

print(l)            # [10, 20, 30]


```

<b>Suppression</b>

l.pop() ou l.pop(i)

Supprime et retourne le dernier élément (ou celui d’indice i).

```
 l = [10, 20, 30]

# Supprimer un élément à un indice donné

y = l.pop(1)

print(y)            # 20

print(l)            # [10, 30]


```

l.remove(x)

Supprime la première occurrence de x.

```
l = [10, 30]

# Supprimer la première occurrence d’une valeur

l.remove(10)

print(l)            # [30]

```

<b>Autres</b>

l.copy()

Crée une copie indépendante de la liste.

```
l = [1, 2, 3]

# Copier une liste

copie = l.copy()

copie.append(4)

print(l)            # [1, 2, 3]

print(copie)        # [1, 2, 3, 4]

```

l.reverse()

Inverse l’ordre des éléments de la liste.

```
l = [1, 2, 3]

# Inverser une liste

l.reverse()

print(l)            # [3, 2, 1]

```

![permission_cat](https://github.com/Wextc/ESI_Bachelier/blob/main/DEV1/Laboratoire/TD11/img/attention.png)

Explication simple:

En Python, certaines méthodes :

modifient l’objet directement

ne retournent rien → leur valeur de retour est None

append(), reverse(), insert(i, x) fait exactement ça.

print(liste.append("quelqu chose")) # Retourne NONE
print(liste.reverse()) # Retourne NONE
print(liste.insert(indice,"élément à insérer") Retourne NONE

Les méthode suivante retourne un résultat:

print(liste.count("quelque chose")) # Retourne combien de fois l'élément et contenu.

---

#### 1.2 Création de listes contenant des éléments aléatoires

Le code ci-dessous crée une liste de 10 entiers choisis aléatoirement entre 0 et 5 inclus :

```
import random                                              # Import le package dont on a besoin

ma_liste = []                                              # Crée une liste vide et et l'assigne à ma_liste

for i in range(10):                                         # Début du loop qui commence par 0 et s'arrête à 10

    ma_liste.append(random.randint(0,5))                    # random.randint(0,5) méthode qui retourne un nombre choisit
                                                            entre 0 et 5.
                                                            #  ma_liste.append() méthode qui rajoute le résultat de la méthode précédente à la lite ma_liste.
                                                            # le for va recommencer ce procéssus 10 fois.

print(ma_liste)                                             # Une fois qu'on sort de la boucle, on obtient ma_liste qui
                                                            contient la valeur finale de ma_liste.
```

Le code ci-dessous crée une liste de 10 caractères minuscules choisis aléatoirement dans les lettres de l’alphabet latin :

```
import random

caracteres = "abcdefghijklmnopqrstuvwxyz"

ma_liste = []

for i in range(10):

    ma_liste.append(random.choice(caracteres))  # random.choice(caracteres) méthode qui choisit une lettre au hasard/
                                                # Comme on est dans la boucle on recommence cela 10

print(ma_liste)                                 #  On obtient le résultat final de ma_liste.

```

#### 1.3 Opérations sur les listes

<b> Manipulations de base </b>

créez une liste liste1 contenant quelques entiers ;

```
liste1 = [1,2,3]

```

vérifiez la longueur de liste1 ;

```
liste1 = [1,2,3]

print(len(liste1))

```

à l’aide de l’opérateur in vérifier la présence de la valeur 0 ;

```
liste1 = [1,2,3]

print(0 in liste1)  # Retourne False

```

ajoutez à cette liste, en dernière position, la valeur 15 ;

```
liste1 = [1,2,3]

print(liste1.append(15)) # Retourne NONE

# La vrai réponse :>

liste1 = [1,2,3]

liste1.append(15)    # Ici méthode va modifier liste1. Une fois modifiée seulement, on peut print.

print(liste1)        # On obtient le réslulatat suivant :> [1, 2, 3, 15]

# Ou

liste2 =  liste1.append(15)

print(liste2)

```

inversez l’ordre des éléments de la liste ;

```
liste1 = [1, 2, 3, 15]

print(liste1.revers()) # Donne NONE.

# Voici le résultat :>

liste1.reverse()        # On modifie puis on print la valeur modifiée. Même explication que pour append()

print(liste1)

# Ou

liste3 = liste2.reverse()

print(liste3)

```

utilisez le slicing pour créer une nouvelle liste (liste4) contenant les éléments d’indice pair de la liste1 ;

```
liste3 = [15, 3, 2, 1]

liste4 = liste1[2:3]

print(liste4)


# Ici le code suivant marche aussi.

print(liste1[2:3])

```

grâce à la méthode count, comptez le nombre d’occurrences dans cette liste de la valeur 3 ;

```
liste5 = [15,15,15, 3, 2, 1]

print(liste5.count(15)) # Ici c'est possible.

# Ou

liste6 = liste5.count(15) # Réponse 3. Cela veut dire que dans le liste5 il y 3 fois 15.

liste6 = liste5.count(3)   #  Cela veut dire que dans le liste5 il y a une fois le chiffre 3.

```

insérez en deuxième position la valeur 7 ;

```
liste5 = [15,15,15, 3, 2, 1]

liste7 = print(liste5.insert(1, 7))  # insert(1, 2) méthode qui à l'élément qui se trouve à la 2ème position l'élément de
                                      valeur 2. Dans le liste on compte à partir de 0, 1 est la seconde postion.

print(liste7)

#  Ou

liste5.insert(1, 7)

print(liste5)


# Modification

liste5[1] = 7

print(liste5)

insert(i, x) ➜ ajoute un élément ➜ taille ↑ => Insertion

liste[i] = x ➜ remplace un élément ➜ taille inchangée => Modification

```

en utilisant le slicing, remplacez le deuxième et le troisième élément de liste1 par les éléments de la liste [10,12,14,16] ;

```
liste1 = [1, 2, 3, 5, 6, 7, 8, 9, "a", "b", "c", "d", "e", "f", "g", "h"]

liste1[1:3] = [10, 12, 14, 16]

print(liste1)  # Remplace l'élément situé à entre l'index 1 et 3 l'array > [10, 12, 14, 16]

# Résultat

[1, 10, 12, 14, 16, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

```

à l’aide de la méthode copy de la classe list, créez une copie de liste1 nommée liste2. Exécutez ensuite l’instruction liste3 = liste1.

Quelle est la différence entre ces deux instructions ?

```
liste3 = liste1.copy() # Méthode qui sert seulement à copier la liste sur laquelle on l’appelle
print(liste3)  # [1, 2, 3, 5, 6, 7, 8, 9]

# Si ton objectif est de combiner liste1 et liste2

liste3 = liste1 + liste2

print(liste3)

```

extrayez de la liste1 le dernier élément ;

```
liste3 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 1, 2, 3, 5, 6, 7, 8, 9] # Il faut extraire la liste1 :> [ 1, 2, 3, 5, 6, 7,
                                                                            8, 9]
liste1 = liste3[8:]

print(liste1)

```

extrayez de la liste1 l’élément en 4ème position ;

```
liste1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

print(liste1[3])

```

triez liste1 en ordre ascendant (du plus petit au plus grand) ;

```
liste1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

liste1.sort()

print(liste1)

```

triez liste2 en ordre descendant (du plus grand au plus petit) ;

```


liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

liste2.sort(reverse=True)

print(liste2)

```

cherchez l’indice d’une valeur présente dans liste2 ;

```

liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

print(liste2.index(7))

```

supprimez une valeur présente dans liste2 ;

```

liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

liste2.remove(6)

print(liste2) # résutat :  [9, 8, 7, 5, 3, 2, 1]

```

que se passe-t-il si vous supprimez une valeur non présente dans liste2 ?

```
liste2.remove(100) # ValueError: list.remove(x): x not in list



```

à l’aide de la méthode extend de la classe list, ajoutez à la fin de liste1 les éléments de liste2 situés entre la 3ième et la 7ième position inclues ;

```
liste1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

liste1.extend(liste2[2:7])

print(liste1)

```

supprimez toutes les valeurs de liste2 ;

```
liste2 = [1, 2, 3, 5, 6, 7, 8, 9]

liste2.clear()

print(liste2) # Résultal :   []

```

à l’aide de la fonction del supprimez le premier élément de liste1.

```
liste1 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']

del liste1[0]

print(liste1)

```

#### Exercice 1.2 Rien c’est pas grand chose ... mais c’est important !

```
mots = ['Carottes', 'Poireaux', 'Tomates', 'Aubergines', 'Courgettes']
mots = mots.append("Brocolis")

```

Donne :

```
None # C'est ce que contient la liste.

```

Lorsque ce programme est exécuté, la variable mots ne contient plus une liste, mais la valeur None.

Au départ, mots est bien une liste contenant plusieurs légumes. Lorsque l’instruction mots.append("Brocolis") est exécutée, Python ajoute correctement l’élément "Brocolis" dans la liste existante. Cependant, la méthode append() a une particularité importante : elle modifie la liste directement et ne renvoie aucune valeur. Sa valeur de retour est donc None.

Dans la ligne suivante, le résultat de mots.append("Brocolis") est affecté à la variable mots. Autrement dit, la variable mots est remplacée par la valeur retournée par append(), c’est-à-dire None. La référence vers la liste est alors perdue.

C’est pour cette raison qu’après l’exécution du code, mots ne contient plus la liste de légumes mais la valeur None. Pour éviter ce problème, il faut appeler append() sans réaffecter son résultat, car cette méthode agit directement sur la liste existante.Lorsque ce programme est exécuté, la variable mots ne contient plus une liste, mais la valeur None.

Au départ, mots est bien une liste contenant plusieurs légumes. Lorsque l’instruction mots.append("Brocolis") est exécutée, Python ajoute correctement l’élément "Brocolis" dans la liste existante. Cependant, la méthode append() a une particularité importante : elle modifie la liste directement et ne renvoie aucune valeur. Sa valeur de retour est donc None.

Dans la ligne suivante, le résultat de mots.append("Brocolis") est affecté à la variable mots. Autrement dit, la variable mots est remplacée par la valeur retournée par append(), c’est-à-dire None. La référence vers la liste est alors perdue.

C’est pour cette raison qu’après l’exécution du code, mots ne contient plus la liste de légumes mais la valeur None. Pour éviter ce problème, il faut appeler append() sans réaffecter son résultat, car cette méthode agit directement sur la liste existante.

#### Exercice 1.3 Le parcours d’une liste est semé d’embûches

Lorsqu’on exécute le premier programme, la boucle for parcourt une copie de la liste grâce au slicing mots[:]. Cela signifie que Python crée d’abord une nouvelle liste contenant les mêmes éléments que mots, puis la boucle itère sur cette copie. Pendant ce temps, la liste originale mots peut être modifiée sans influencer le déroulement de la boucle. À chaque itération, l’élément courant est ajouté à la fin de la liste originale. La boucle s’exécute donc un nombre de fois fixe (égal au nombre d’éléments de départ), et à la fin, la liste mots contient simplement deux fois les mêmes éléments.

Dans le second programme, la boucle for parcourt directement la liste mots elle-même. Or, pendant cette itération, on ajoute de nouveaux éléments à cette même liste avec append(). Comme la liste s’allonge au fur et à mesure, le parcours ne se termine jamais : chaque nouvel élément ajouté est à son tour parcouru par la boucle, ce qui provoque une boucle infinie (ou un programme qui semble bloqué). La taille de la liste augmente continuellement.

Ces deux comportements s’expliquent par une propriété fondamentale des listes en Python : une boucle for parcourt la structure sur laquelle elle itère. Si cette structure est une copie, les modifications n’ont aucun effet sur la boucle ; si c’est la liste originale, toute modification de sa taille influence directement le parcours. C’est pour cette raison qu’il est généralement déconseillé de modifier une liste pendant qu’on la parcourt, sauf si l’on travaille explicitement sur une copie.

#### 1.4 Listes en compréhension

Les listes en compréhension permettent de créer des listes en Python de manière plus concise, plus lisible et souvent plus efficace qu’avec une boucle classique. Le principe consiste à construire une liste en évaluant une expression pour chaque élément d’une séquence, tout en pouvant appliquer une condition de filtrage.

Cette écriture est inspirée des mathématiques, et plus précisément de la notation en compréhension des ensembles. Par exemple, l’ensemble des entiers naturels dont le carré est inférieur ou égal à 25 peut s’écrire mathématiquement comme l’ensemble des valeurs i appartenant à ℕ telles que i² ≤ 25. En Python, cette idée est traduite sous forme de liste en compréhension, où l’on parcourt une suite de valeurs et où l’on ne conserve que celles qui respectent une condition donnée.

Ainsi, l’instruction ma_liste = [x for x in range(25) if x**2 <= 25] crée une liste contenant uniquement les entiers dont le carré est inférieur ou égal à 25. Pour chaque valeur de x dans l’intervalle défini par range(25), Python calcule x\*\*2 et ajoute x à la liste uniquement si la condition est satisfaite. La condition if est facultative : elle permet de filtrer les éléments, mais on peut très bien créer une liste sans condition.

La même liste peut être obtenue à l’aide d’une boucle for classique, en testant la condition avec un if et en ajoutant les éléments un à un avec la méthode append(). Cette approche est plus longue à écrire et moins compacte, mais elle repose exactement sur le même mécanisme logique. La liste en compréhension est donc une écriture optimisée et synthétique de cette boucle.

Enfin, les listes en compréhension ne servent pas uniquement à filtrer des valeurs. Elles peuvent aussi être utilisées pour générer des données, comme dans l’exemple où l’on crée une liste de dix nombres entiers choisis aléatoirement entre 0 et 20. Ici, la compréhension permet d’exécuter plusieurs fois une expression (le tirage aléatoire) et de stocker directement les résultats dans une liste, sans avoir besoin d’écrire une boucle explicite.
