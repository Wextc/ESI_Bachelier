# Les tuples - ()

Un tuple est une structure de donn√©es en Python qui permet de regrouper plusieurs valeurs sous un m√™me nom. Chaque valeur peut √™tre consult√©e √† l‚Äôaide d‚Äôun indice, c‚Äôest-√†-dire un num√©ro qui indique sa position dans le tuple. Comme pour les listes, l‚Äôindice du premier √©l√©ment est toujours 0. La particularit√© du tuple est qu‚Äôil est immuable : une fois cr√©√©, son contenu ne peut plus √™tre modifi√©.

Pour cr√©er un tuple, on peut utiliser des parenth√®ses, comme dans (1, 2, 3, 4, 5), ou bien la fonction tuple(), par exemple tuple(range(10_000_000)). Dans le premier cas, le tuple contient les valeurs 1 √† 5, accessibles directement par leur indice : tuple_1[0] vaut 1, tuple_1[3] vaut 4, etc. Dans le second cas, le tuple contient une suite de valeurs allant de 0 √† 9 999 999, et l‚Äôacc√®s se fait de la m√™me mani√®re : tuple_2[1_000_000] renvoie 1 000 000.

Il est √©galement possible d‚Äô√©crire des nombres de grande taille en s√©parant les chiffres avec des caract√®res underscore (\_) afin de rendre le code plus lisible. Par exemple, 10_000_000 est strictement √©quivalent √† 10000000. Python ignore ces soulignements lors de l‚Äôinterpr√©tation du nombre, mais l‚Äô√©criture est plus claire pour l‚Äôhumain.

Exemples :

```
tuple_1 = (1, 2, 3, 4, 5)

tuple_2 = tuple(range(10_000_000))

```

<b>Voici toutes les m√©thodes qui s'applique aux tuples.</b>

<b> M√©thodes de tuple (Python)</b>

üîπ M√©thodes d‚Äôinstance

| M√©thode                  | Description                         |
| ------------------------ | ----------------------------------- |
| `__add__(value)`         | Retourne `self + value`             |
| `__contains__(key)`      | V√©rifie si `key` est dans le tuple  |
| `__eq__(value)`          | `self == value`                     |
| `__ge__(value)`          | `self >= value`                     |
| `__getattribute__(name)` | R√©cup√®re un attribut                |
| `__getitem__(key)`       | Acc√®s par index ou slice            |
| `__getnewargs__()`       | Utilis√© en interne pour le pickling |
| `__gt__(value)`          | `self > value`                      |
| `__hash__()`             | Retourne le hash du tuple           |
| `__iter__()`             | Renvoie un it√©rateur sur le tuple   |
| `__le__(value)`          | `self <= value`                     |
| `__len__()`              | Longueur du tuple                   |
| `__lt__(value)`          | `self < value`                      |
| `__mul__(value)`         | `self * value` (r√©p√©tition)         |
| `__ne__(value)`          | `self != value`                     |
| `__repr__()`             | Repr√©sentation officielle du tuple  |
| `__rmul__(value)`        | `value * self`                      |

<b>M√©thodes de classe</b>

| M√©thode                  | Description                                 |
| ------------------------ | ------------------------------------------- |
| `__class_getitem__(...)` | Supporte les annotations de type (PEP 585). |

<b>M√©thodes statiques</b>

| Sous-classe          |
| -------------------- |
| `asyncgen_hooks`     |
| `UnraisableHookArgs` |

<b>Exercice 1 : Maximum</b>

Soit le tuple suivant : (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84) √âcrivez une fonction ya_max qui recherche et retourne la valeur maximale de ce tuple. Affichez le r√©sultat de votre fonction de recherche de maximum et celui de la fonction built in max.

```
def ya_max(t):
    max_val = t[0]              # on part du premier √©l√©ment
    for val in t:               # on parcourt le tuple
        if val > max_val:       # si on trouve plus grand
            max_val = val
    return max_val


# Tuple donn√©
t = (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84)

# R√©sultats
print("Maximum trouv√© avec ya_max :", ya_max(t))
print("Maximum trouv√© avec max()  :", max(t))

```

#### Temps d‚Äôacc√®s

Le temps d‚Äôacc√®s correspond au temps n√©cessaire pour qu‚Äôun ordinateur atteigne une zone m√©moire et en r√©cup√®re la valeur qui s‚Äôy trouve. Pour mesurer ce temps, on enregistre simplement l‚Äôinstant pr√©cis juste avant l‚Äôacc√®s et l‚Äôinstant juste apr√®s. La diff√©rence entre ces deux instants repr√©sente alors la dur√©e r√©elle de l‚Äôop√©ration.

Dans l‚Äôexemple donn√©, on utilise le module time pour mesurer ce d√©lai. La fonction access_time prend un tuple, rel√®ve l‚Äôheure courante, parcourt tous ses √©l√©ments un √† un, puis rel√®ve de nouveau l‚Äôheure. En soustrayant les deux mesures, on obtient le temps total n√©cessaire pour acc√©der √† l‚Äôensemble des valeurs du tuple. Lorsque le tuple contient tr√®s peu d‚Äô√©l√©ments, ce temps est presque imperceptible. Mais plus le tuple devient grand, plus la dur√©e totale de lecture de tous ses √©l√©ments augmente et peut finir par devenir significative.

![permission_cat_personnes](https://github.com/Wextc/ESI_Bachelier/blob/main/DEV1/Laboratoire/TD10/img/temps_acces.png)

#### Immuabilit√©

Les tuples sont immuables : on ne peut ni changer leurs √©l√©ments ni modifier leur taille.
Pour cr√©er de nouveaux tuples, on utilise plut√¥t des op√©rations comme + ou \*, qui g√©n√®rent un nouvel objet sans affecter les anciens.

Un tuple en Python est une structure de donn√©es immuable : une fois cr√©√©, son contenu ne peut pas √™tre modifi√©. Cela signifie que :

On ne peut pas changer l‚Äôune de ses valeurs.

On ne peut pas ajouter un √©l√©ment.

On ne peut pas supprimer un √©l√©ment.

Par exemple :

```
tuple_1 = (10, 20, 30)
tuple_1[0] = -1   # Erreur, un tuple ne peut pas √™tre modifi√©

```

Comme les tuples sont immuables, Python ne propose aucune m√©thode pour ajouter ou retirer un √©l√©ment (contrairement aux listes).

Concat√©nation avec l‚Äôop√©rateur +

M√™me si on ne peut pas modifier un tuple, on peut en cr√©er de nouveaux √† partir d‚Äôautres tuples.
L‚Äôop√©rateur + permet de concat√©ner deux tuples, c‚Äôest-√†-dire de former un nouveau tuple contenant toutes les valeurs des deux :

```
t1 = (1, 2)
t2 = (3, 4)
t3 = t1 + t2
print(t3)  # (1, 2, 3, 4)

```

Ici, ni t1 ni t2 ne changent : c‚Äôest un nouveau tuple qui est cr√©√©.

R√©p√©tition avec l‚Äôop√©rateur \*

L‚Äôop√©rateur \*, appliqu√© √† un tuple et un entier n, cr√©e un nouveau tuple o√π les valeurs du tuple d‚Äôorigine sont r√©p√©t√©es n fois :

```
t = (5, 6)
t4 = t * 3
print(t4)  # (5, 6, 5, 6, 5, 6)

```

L√† encore, le tuple initial n‚Äôest pas modifi√© : un nouveau tuple est produit.

#### D√©coupage

Le d√©coupage (ou slicing) est une fa√ßon tr√®s pratique d‚Äôextraire une partie d‚Äôun tuple en Python.
On utilise la notation a[i:j] pour r√©cup√©rer tous les √©l√©ments dont l‚Äôindice est entre i (inclus) et j (exclu). C‚Äôest ce qu‚Äôon appelle un intervalle semi-ouvert :

i est inclus ‚Üí l‚Äô√©l√©ment d‚Äôindice i fait partie du r√©sultat

j est exclu ‚Üí l‚Äô√©l√©ment d‚Äôindice j ne fait pas partie du r√©sultat

Le slicing ne modifie pas le tuple d‚Äôorigine : il cr√©e un nouveau tuple, dont les indices repartent √† 0.

Exemple simple

```
tuple_1 = ('a', 'b', 'c', 'd', 'e')
tuple_3 = tuple_1[2:4]
print(tuple_3)

```

R√©sultat :

```
('c', 'd')

```

Explication :

```
tuple_1[2] ‚Üí 'c' (inclus)

tuple_1[3] ‚Üí 'd' (inclus)

tuple_1[4] ‚Üí 'e' (exclu car c‚Äôest la borne j)

```

Donc seuls 'c' et 'd' apparaissent dans le nouveau tuple.

Autres exemples utiles

1. Extraire depuis un indice jusqu‚Äô√† la fin

```
t = (10, 20, 30, 40)
print(t[1:])      # (20, 30, 40)

```

2. Extraire depuis le d√©but jusqu‚Äô√† un indice

```
t = (10, 20, 30, 40)
print(t[:3])      # (10, 20, 30)

```

3. Extraire tout sauf le premier et le dernier √©l√©ment

```
t = (1, 2, 3, 4, 5)
print(t[1:-1])    # (2, 3, 4)

```

4. Copie compl√®te du tuple

```
t = (7, 8, 9)
print(t[:])       # (7, 8, 9)

```

<b>Les diff√©rentes variables de tuples</b>

Soit un tuple x.

```
x = (11, 12, 13, 14, 15, 16, 17)

```

<b>Variantes simples (borne gauche, borne droite)</b>

| Expression | Description                           | R√©sultat                       |
| ---------- | ------------------------------------- | ------------------------------ |
| `x[:3]`    | Du d√©but jusqu‚Äô√† l‚Äôindice 3 (exclu)   | `(11, 12, 13)`                 |
| `x[3:]`    | √Ä partir de l‚Äôindice 3 jusqu‚Äô√† la fin | `(14, 15, 16, 17)`             |
| `x[:]`     | Copie compl√®te du tuple               | `(11, 12, 13, 14, 15, 16, 17)` |
| `x[2:5]`   | De l‚Äôindice 2 √† 5 (exclu)             | `(13, 14, 15)`                 |

<b>Variantes avec step positif</b>

| Expression | Description                       | R√©sultat           |
| ---------- | --------------------------------- | ------------------ |
| `x[0:7:2]` | Un √©l√©ment sur deux entre 0 et 7  | `(11, 13, 15, 17)` |
| `x[1:7:2]` | Un √©l√©ment sur deux √† partir de 1 | `(12, 14, 16)`     |
| `x[::2]`   | Toute la s√©quence, pas de 2       | `(11, 13, 15, 17)` |

Step = 3

| Expression | Description            | R√©sultat       |
| ---------- | ---------------------- | -------------- |
| `x[0:7:3]` | Un √©l√©ment sur trois   | `(11, 14, 17)` |
| `x[1:6:3]` | Pas de 3 √† partir de 1 | `(12, 15)`     |

<b>Step positif mais bornes larges</b>

| Expression | Description                           | R√©sultat                       |
| ---------- | ------------------------------------- | ------------------------------ |
| `x[0:100]` | Stop trop grand ‚Üí s‚Äôarr√™te au maximum | `(11, 12, 13, 14, 15, 16, 17)` |
| `x[::5]`   | Saut de 5                             | `(11, 16)`                     |

<b>Variantes avec step n√©gatif (lecture √† l‚Äôenvers)</b>

| Expression | Description   | R√©sultat                       |
| ---------- | ------------- | ------------------------------ |
| `x[::-1]`  | Tuple invers√© | `(17, 16, 15, 14, 13, 12, 11)` |

Step n√©gatif simple

| Expression  | Description                | R√©sultat               |
| ----------- | -------------------------- | ---------------------- |
| `x[5:2:-1]` | De 5 √† 2 exclu, en arri√®re | `(16, 15, 14)`         |
| `x[6:1:-1]` | De 6 √† 1 exclu             | `(17, 16, 15, 14, 13)` |
| `x[4:0:-1]` | De 4 √† 0 exclu             | `(15, 14, 13, 12)`     |

<b>Step n√©gatif avec step > 1</b>

Step = ‚Äì2

| Expression  | Description             | R√©sultat           |
| ----------- | ----------------------- | ------------------ |
| `x[6:0:-2]` | Recule de 2             | `(17, 15, 13, 11)` |
| `x[5:1:-2]` | Recule de deux depuis 5 | `(16, 14, 12)`     |

Step = ‚Äì3

| Expression  | Description             | R√©sultat       |
| ----------- | ----------------------- | -------------- |
| `x[6:0:-3]` | Recule de 3             | `(17, 14, 11)` |
| `x[5:2:-3]` | Recule de 3 jusqu‚Äô√† > 2 | `(16,)`        |
| `x[5:3:-3]` | Recule de 3 jusqu‚Äô√† > 3 | `(16,)`        |

<b>Cas o√π le slicing donne un tuple VIDE</b>

| Expression  | Raison                         | R√©sultat |
| ----------- | ------------------------------ | -------- |
| `x[5:2:1]`  | Step positif mais start > stop | `()`     |
| `x[4:1:1]`  | Step positif mais start > stop | `()`     |
| `x[1:5:-1]` | Step n√©gatif mais start < stop | `()`     |
| `x[1:2:-1]` | Atteint la borne stop (exclue) | `()`     |

#### La mutuabilit√©

En Python, les listes et les tuples diff√®rent principalement par leur mutabilit√©, c‚Äôest-√†-dire leur capacit√© √† √™tre modifi√©s apr√®s leur cr√©ation.
Les listes sont des objets mutables : on peut changer leur contenu √† tout moment. Cela inclut la modification d‚Äôune valeur existante, l‚Äôajout de nouveaux √©l√©ments, la suppression d‚Äôautres, ou encore la r√©organisation de l‚Äôensemble. Par exemple, si l‚Äôon cr√©e la liste liste = [1, 2, 3], il est possible de remplacer son premier √©l√©ment par 100, d‚Äôy ajouter un 4 gr√¢ce √† append, ou de supprimer l‚Äô√©l√©ment d‚Äôindice 1. Toutes ces op√©rations modifient r√©ellement la structure stock√©e en m√©moire.

√Ä l‚Äôinverse, les tuples sont immutables : une fois cr√©√©s, ils ne peuvent plus √™tre modifi√©s. Il est impossible de changer une valeur, d‚Äôen ajouter ou d‚Äôen supprimer, et aucune m√©thode telle que append, remove ou pop n‚Äôexiste pour eux. Ainsi, si l‚Äôon √©crit t = (1, 2, 3), tenter de faire t[0] = 100 provoquera une erreur, car Python interdit toute modification directe du contenu d‚Äôun tuple. Celui-ci reste donc d√©finitivement fig√©.

Cependant, certaines op√©rations peuvent donner l‚Äôimpression qu‚Äôun tuple change. Par exemple, lorsqu‚Äôon √©crit :

```
t = (1, 2, 3)
t = t + (4,)

```

le tuple ne se modifie pas r√©ellement. Python cr√©e en r√©alit√© un nouveau tuple, (1, 2, 3, 4), puis affecte cette nouvelle structure √† la variable t. L‚Äôancien tuple reste inchang√© ; il est simplement remplac√© dans la variable. Ainsi, m√™me si la syntaxe peut sembler similaire √† une modification, la nature immuable des tuples reste intacte.

| Type      | Mutable ? | Peut changer sa taille ? | Peut changer ses valeurs ? | M√©thodes d‚Äôajout/suppression ? |
| --------- | --------- | ------------------------ | -------------------------- | ------------------------------ |
| **Liste** | ‚úî Oui     | ‚úî Oui                    | ‚úî Oui                      | ‚úî Oui (append, pop, remove‚Ä¶)   |
| **Tuple** | ‚ùå Non    | ‚ùå Non                   | ‚ùå Non                     | ‚ùå Non                         |

<b>3 Exercice - Une seule ligne</b>

```
import random

# 1) plateau = liste de 20 cases initialis√©es √† 0
SIZE = 20

def display(board):
    """Affiche les indices puis le contenu du plateau."""
    # ligne des indices
    print(" ".join(f"{i:2d}" for i in range(SIZE)))
    # ligne des valeurs (0 = case vide ‚Üí on affiche un point)
    print(" ".join(f"{v if v != 0 else '.' :2}" for v in board))
    print()  # ligne vide


def add_2_values(board):
    """Ajoute 1 ou 2 valeurs al√©atoires (1..4) dans des cases libres."""
    # indices des cases libres
    free_positions = [i for i, v in enumerate(board) if v == 0]

    if not free_positions:
        # plus de place
        return

    if len(free_positions) == 1:
        # une seule case libre ‚Üí on ne met qu'une valeur
        idx = free_positions[0]
        board[idx] = random.randint(1, 4)
    else:
        # au moins 2 cases libres ‚Üí on en choisit 2 diff√©rentes
        i1, i2 = random.sample(free_positions, 2)
        board[i1] = random.randint(1, 4)
        board[i2] = random.randint(1, 4)


def move(board, origin, destination):
    """
    D√©place la valeur de origin vers destination si :
    - origin contient une valeur non nulle
    - destination est vide
    - toutes les cases entre origin et destination sont vides
    Retourne True si le d√©placement a √©t√© fait, False sinon.
    """
    if origin < 0 or origin >= SIZE or destination < 0 or destination >= SIZE:
        return False

    if board[origin] == 0:
        return False  # rien √† d√©placer

    if board[destination] != 0:
        return False  # case d'arriv√©e non vide

    # v√©rifier que toutes les cases entre les deux sont vides
    start = min(origin, destination) + 1
    end = max(origin, destination)
    for i in range(start, end):
        if board[i] != 0:
            return False  # chemin bloqu√©

    # d√©placement
    board[destination] = board[origin]
    board[origin] = 0
    return True


def read_positions():
    """
    Lit deux entiers 'origin destination' au clavier.
    Renvoie un tuple (origin, destination).
    Si l'utilisateur tape 'q', on renvoie None pour signaler l'arr√™t.
    """
    while True:
        s = input("Enter origin and destination (or 'q' to quit): ").strip()
        if s.lower() == "q":
            return None

        parts = s.split()
        if len(parts) != 2:
            print("Veuillez entrer deux entiers s√©par√©s par un espace.")
            continue

        try:
            origin = int(parts[0])
            destination = int(parts[1])
            return (origin, destination)
        except ValueError:
            print("Veuillez entrer des nombres entiers.")
            continue


def remove_3_inline(board):
    """
    Cherche des s√©quences d'au moins 3 valeurs identiques cons√©cutives
    et les supprime (les remplace par 0).
    """
    i = 0
    while i < SIZE:
        if board[i] == 0:
            i += 1
            continue

        # on cherche la longueur du bloc de valeurs identiques
        j = i + 1
        while j < SIZE and board[j] == board[i]:
            j += 1

        length = j - i
        if length >= 3:
            # on efface le bloc
            for k in range(i, j):
                board[k] = 0
        i = j


def is_full(board):
    """Retourne True si le plateau ne contient plus aucune case vide (0)."""
    return all(v != 0 for v in board)


def main():
    # initialisation du plateau
    board = [0] * SIZE

    # au d√©but du jeu, on ajoute 2 valeurs al√©atoires
    add_2_values(board)

    turns = 0

    # boucle principale
    while True:
        display(board)

        if is_full(board):
            print("Le plateau est plein. Nombre de tours jou√©s :", turns)
            break

        pos = read_positions()
        if pos is None:
            print("Vous avez quitt√© la partie. Tours jou√©s :", turns)
            break

        origin, destination = pos

        if not move(board, origin, destination):
            print("D√©placement impossible (case vide, chemin bloqu√© ou indices invalides).")
            continue  # on ne compte pas ce tour

        # d√©placement r√©ussi ‚Üí on compte le tour
        turns += 1

        # l'ordinateur ajoute 2 valeurs
        add_2_values(board)

        # on enl√®ve les √©ventuels triplets cons√©cutifs
        remove_3_inline(board)


if __name__ == "__main__":
    main()


```
