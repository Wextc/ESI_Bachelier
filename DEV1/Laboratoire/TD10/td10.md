# Les tuples - ()

Un tuple est une structure de donnÃ©es en Python qui permet de regrouper plusieurs valeurs sous un mÃªme nom. Chaque valeur peut Ãªtre consultÃ©e Ã  lâ€™aide dâ€™un indice, câ€™est-Ã -dire un numÃ©ro qui indique sa position dans le tuple. Comme pour les listes, lâ€™indice du premier Ã©lÃ©ment est toujours 0. La particularitÃ© du tuple est quâ€™il est immuable : une fois crÃ©Ã©, son contenu ne peut plus Ãªtre modifiÃ©.

Pour crÃ©er un tuple, on peut utiliser des parenthÃ¨ses, comme dans (1, 2, 3, 4, 5), ou bien la fonction tuple(), par exemple tuple(range(10_000_000)). Dans le premier cas, le tuple contient les valeurs 1 Ã  5, accessibles directement par leur indice : tuple_1[0] vaut 1, tuple_1[3] vaut 4, etc. Dans le second cas, le tuple contient une suite de valeurs allant de 0 Ã  9 999 999, et lâ€™accÃ¨s se fait de la mÃªme maniÃ¨re : tuple_2[1_000_000] renvoie 1 000 000.

Il est Ã©galement possible dâ€™Ã©crire des nombres de grande taille en sÃ©parant les chiffres avec des caractÃ¨res underscore (\_) afin de rendre le code plus lisible. Par exemple, 10_000_000 est strictement Ã©quivalent Ã  10000000. Python ignore ces soulignements lors de lâ€™interprÃ©tation du nombre, mais lâ€™Ã©criture est plus claire pour lâ€™humain.

Exemples :

```
tuple_1 = (1, 2, 3, 4, 5)

tuple_2 = tuple(range(10_000_000))

```

<b>Voici toutes les mÃ©thodes qui s'applique aux tuples.</b>

<b> MÃ©thodes de tuple (Python)</b>

ğŸ”¹ MÃ©thodes dâ€™instance

| MÃ©thode                  | Description                         |
| ------------------------ | ----------------------------------- |
| `__add__(value)`         | Retourne `self + value`             |
| `__contains__(key)`      | VÃ©rifie si `key` est dans le tuple  |
| `__eq__(value)`          | `self == value`                     |
| `__ge__(value)`          | `self >= value`                     |
| `__getattribute__(name)` | RÃ©cupÃ¨re un attribut                |
| `__getitem__(key)`       | AccÃ¨s par index ou slice            |
| `__getnewargs__()`       | UtilisÃ© en interne pour le pickling |
| `__gt__(value)`          | `self > value`                      |
| `__hash__()`             | Retourne le hash du tuple           |
| `__iter__()`             | Renvoie un itÃ©rateur sur le tuple   |
| `__le__(value)`          | `self <= value`                     |
| `__len__()`              | Longueur du tuple                   |
| `__lt__(value)`          | `self < value`                      |
| `__mul__(value)`         | `self * value` (rÃ©pÃ©tition)         |
| `__ne__(value)`          | `self != value`                     |
| `__repr__()`             | ReprÃ©sentation officielle du tuple  |
| `__rmul__(value)`        | `value * self`                      |

<b>MÃ©thodes de classe</b>

| MÃ©thode                  | Description                                 |
| ------------------------ | ------------------------------------------- |
| `__class_getitem__(...)` | Supporte les annotations de type (PEP 585). |

<b>MÃ©thodes statiques</b>

| Sous-classe          |
| -------------------- |
| `asyncgen_hooks`     |
| `UnraisableHookArgs` |

<b>Exercice 1 : Maximum</b>

Soit le tuple suivant : (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84) Ã‰crivez une fonction ya_max qui recherche et retourne la valeur maximale de ce tuple. Affichez le rÃ©sultat de votre fonction de recherche de maximum et celui de la fonction built in max.

```
def ya_max(t):
    max_val = t[0]              # on part du premier Ã©lÃ©ment
    for val in t:               # on parcourt le tuple
        if val > max_val:       # si on trouve plus grand
            max_val = val
    return max_val


# Tuple donnÃ©
t = (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84)

# RÃ©sultats
print("Maximum trouvÃ© avec ya_max :", ya_max(t))
print("Maximum trouvÃ© avec max()  :", max(t))

```

#### Temps dâ€™accÃ¨s

Le temps dâ€™accÃ¨s correspond au temps nÃ©cessaire pour quâ€™un ordinateur atteigne une zone mÃ©moire et en rÃ©cupÃ¨re la valeur qui sâ€™y trouve. Pour mesurer ce temps, on enregistre simplement lâ€™instant prÃ©cis juste avant lâ€™accÃ¨s et lâ€™instant juste aprÃ¨s. La diffÃ©rence entre ces deux instants reprÃ©sente alors la durÃ©e rÃ©elle de lâ€™opÃ©ration.

Dans lâ€™exemple donnÃ©, on utilise le module time pour mesurer ce dÃ©lai. La fonction access_time prend un tuple, relÃ¨ve lâ€™heure courante, parcourt tous ses Ã©lÃ©ments un Ã  un, puis relÃ¨ve de nouveau lâ€™heure. En soustrayant les deux mesures, on obtient le temps total nÃ©cessaire pour accÃ©der Ã  lâ€™ensemble des valeurs du tuple. Lorsque le tuple contient trÃ¨s peu dâ€™Ã©lÃ©ments, ce temps est presque imperceptible. Mais plus le tuple devient grand, plus la durÃ©e totale de lecture de tous ses Ã©lÃ©ments augmente et peut finir par devenir significative.

![permission_cat_personnes](https://github.com/Wextc/ESI_Bachelier/blob/main/DEV1/Laboratoire/TD10/img/temps_acces.png)

#### ImmuabilitÃ©

Les tuples sont immuables : on ne peut ni changer leurs Ã©lÃ©ments ni modifier leur taille.
Pour crÃ©er de nouveaux tuples, on utilise plutÃ´t des opÃ©rations comme + ou \*, qui gÃ©nÃ¨rent un nouvel objet sans affecter les anciens.

Un tuple en Python est une structure de donnÃ©es immuable : une fois crÃ©Ã©, son contenu ne peut pas Ãªtre modifiÃ©. Cela signifie que :

On ne peut pas changer lâ€™une de ses valeurs.

On ne peut pas ajouter un Ã©lÃ©ment.

On ne peut pas supprimer un Ã©lÃ©ment.

Par exemple :

```
tuple_1 = (10, 20, 30)
tuple_1[0] = -1   # Erreur, un tuple ne peut pas Ãªtre modifiÃ©

```

Comme les tuples sont immuables, Python ne propose aucune mÃ©thode pour ajouter ou retirer un Ã©lÃ©ment (contrairement aux listes).

ConcatÃ©nation avec lâ€™opÃ©rateur +

MÃªme si on ne peut pas modifier un tuple, on peut en crÃ©er de nouveaux Ã  partir dâ€™autres tuples.
Lâ€™opÃ©rateur + permet de concatÃ©ner deux tuples, câ€™est-Ã -dire de former un nouveau tuple contenant toutes les valeurs des deux :

```
t1 = (1, 2)
t2 = (3, 4)
t3 = t1 + t2
print(t3)  # (1, 2, 3, 4)

```

Ici, ni t1 ni t2 ne changent : câ€™est un nouveau tuple qui est crÃ©Ã©.

RÃ©pÃ©tition avec lâ€™opÃ©rateur \*

Lâ€™opÃ©rateur \*, appliquÃ© Ã  un tuple et un entier n, crÃ©e un nouveau tuple oÃ¹ les valeurs du tuple dâ€™origine sont rÃ©pÃ©tÃ©es n fois :

```
t = (5, 6)
t4 = t * 3
print(t4)  # (5, 6, 5, 6, 5, 6)

```

LÃ  encore, le tuple initial nâ€™est pas modifiÃ© : un nouveau tuple est produit.

#### DÃ©coupage

Le dÃ©coupage (ou slicing) est une faÃ§on trÃ¨s pratique dâ€™extraire une partie dâ€™un tuple en Python.
On utilise la notation a[i:j] pour rÃ©cupÃ©rer tous les Ã©lÃ©ments dont lâ€™indice est entre i (inclus) et j (exclu). Câ€™est ce quâ€™on appelle un intervalle semi-ouvert :

i est inclus â†’ lâ€™Ã©lÃ©ment dâ€™indice i fait partie du rÃ©sultat

j est exclu â†’ lâ€™Ã©lÃ©ment dâ€™indice j ne fait pas partie du rÃ©sultat

Le slicing ne modifie pas le tuple dâ€™origine : il crÃ©e un nouveau tuple, dont les indices repartent Ã  0.

Exemple simple

```
tuple_1 = ('a', 'b', 'c', 'd', 'e')
tuple_3 = tuple_1[2:4]
print(tuple_3)

```

RÃ©sultat :

```
('c', 'd')

```

Explication :

```
tuple_1[2] â†’ 'c' (inclus)

tuple_1[3] â†’ 'd' (inclus)

tuple_1[4] â†’ 'e' (exclu car câ€™est la borne j)

```

Donc seuls 'c' et 'd' apparaissent dans le nouveau tuple.

Autres exemples utiles

1. Extraire depuis un indice jusquâ€™Ã  la fin

```
t = (10, 20, 30, 40)
print(t[1:])      # (20, 30, 40)

```

2. Extraire depuis le dÃ©but jusquâ€™Ã  un indice

```
t = (10, 20, 30, 40)
print(t[:3])      # (10, 20, 30)

```

3. Extraire tout sauf le premier et le dernier Ã©lÃ©ment

```
t = (1, 2, 3, 4, 5)
print(t[1:-1])    # (2, 3, 4)

```

4. Copie complÃ¨te du tuple

```
t = (7, 8, 9)
print(t[:])       # (7, 8, 9)

```
