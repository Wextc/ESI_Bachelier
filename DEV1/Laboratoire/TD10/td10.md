# Les tuples - ()

Un tuple est une structure de donnÃ©es en Python qui permet de regrouper plusieurs valeurs sous un mÃªme nom. Chaque valeur peut Ãªtre consultÃ©e Ã  lâ€™aide dâ€™un indice, câ€™est-Ã -dire un numÃ©ro qui indique sa position dans le tuple. Comme pour les listes, lâ€™indice du premier Ã©lÃ©ment est toujours 0. La particularitÃ© du tuple est quâ€™il est immuable : une fois crÃ©Ã©, son contenu ne peut plus Ãªtre modifiÃ©.

Pour crÃ©er un tuple, on peut utiliser des parenthÃ¨ses, comme dans (1, 2, 3, 4, 5), ou bien la fonction tuple(), par exemple tuple(range(10_000_000)). Dans le premier cas, le tuple contient les valeurs 1 Ã  5, accessibles directement par leur indice : tuple_1[0] vaut 1, tuple_1[3] vaut 4, etc. Dans le second cas, le tuple contient une suite de valeurs allant de 0 Ã  9 999 999, et lâ€™accÃ¨s se fait de la mÃªme maniÃ¨re : tuple_2[1_000_000] renvoie 1 000 000.

Il est Ã©galement possible dâ€™Ã©crire des nombres de grande taille en sÃ©parant les chiffres avec des caractÃ¨res underscore (\_) afin de rendre le code plus lisible. Par exemple, 10_000_000 est strictement Ã©quivalent Ã  10000000. Python ignore ces soulignements lors de lâ€™interprÃ©tation du nombre, mais lâ€™Ã©criture est plus claire pour lâ€™humain.

Exemples :

```
tuple_1 = (1, 2, 3, 4, 5)

tuple_2 = tuple(range(10_000_000))

```

<b>Voici toutes les mÃ©thodes qui s'applique aux tuples.</b>

<b> MÃ©thodes de tuple (Python)</b>

ğŸ”¹ MÃ©thodes dâ€™instance

| MÃ©thode                  | Description                         |
| ------------------------ | ----------------------------------- |
| `__add__(value)`         | Retourne `self + value`             |
| `__contains__(key)`      | VÃ©rifie si `key` est dans le tuple  |
| `__eq__(value)`          | `self == value`                     |
| `__ge__(value)`          | `self >= value`                     |
| `__getattribute__(name)` | RÃ©cupÃ¨re un attribut                |
| `__getitem__(key)`       | AccÃ¨s par index ou slice            |
| `__getnewargs__()`       | UtilisÃ© en interne pour le pickling |
| `__gt__(value)`          | `self > value`                      |
| `__hash__()`             | Retourne le hash du tuple           |
| `__iter__()`             | Renvoie un itÃ©rateur sur le tuple   |
| `__le__(value)`          | `self <= value`                     |
| `__len__()`              | Longueur du tuple                   |
| `__lt__(value)`          | `self < value`                      |
| `__mul__(value)`         | `self * value` (rÃ©pÃ©tition)         |
| `__ne__(value)`          | `self != value`                     |
| `__repr__()`             | ReprÃ©sentation officielle du tuple  |
| `__rmul__(value)`        | `value * self`                      |

<b>MÃ©thodes de classe</b>

| MÃ©thode                  | Description                                 |
| ------------------------ | ------------------------------------------- |
| `__class_getitem__(...)` | Supporte les annotations de type (PEP 585). |

<b>MÃ©thodes statiques</b>

| Sous-classe          |
| -------------------- |
| `asyncgen_hooks`     |
| `UnraisableHookArgs` |

<b>Exercice 1 : Maximum</b>

Soit le tuple suivant : (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84) Ã‰crivez une fonction ya_max qui recherche et retourne la valeur maximale de ce tuple. Affichez le rÃ©sultat de votre fonction de recherche de maximum et celui de la fonction built in max.

```
def ya_max(t):
    max_val = t[0]              # on part du premier Ã©lÃ©ment
    for val in t:               # on parcourt le tuple
        if val > max_val:       # si on trouve plus grand
            max_val = val
    return max_val


# Tuple donnÃ©
t = (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84)

# RÃ©sultats
print("Maximum trouvÃ© avec ya_max :", ya_max(t))
print("Maximum trouvÃ© avec max()  :", max(t))

```

#### Temps dâ€™accÃ¨s

Le temps dâ€™accÃ¨s correspond au temps nÃ©cessaire pour quâ€™un ordinateur atteigne une zone mÃ©moire et en rÃ©cupÃ¨re la valeur qui sâ€™y trouve. Pour mesurer ce temps, on enregistre simplement lâ€™instant prÃ©cis juste avant lâ€™accÃ¨s et lâ€™instant juste aprÃ¨s. La diffÃ©rence entre ces deux instants reprÃ©sente alors la durÃ©e rÃ©elle de lâ€™opÃ©ration.

Dans lâ€™exemple donnÃ©, on utilise le module time pour mesurer ce dÃ©lai. La fonction access_time prend un tuple, relÃ¨ve lâ€™heure courante, parcourt tous ses Ã©lÃ©ments un Ã  un, puis relÃ¨ve de nouveau lâ€™heure. En soustrayant les deux mesures, on obtient le temps total nÃ©cessaire pour accÃ©der Ã  lâ€™ensemble des valeurs du tuple. Lorsque le tuple contient trÃ¨s peu dâ€™Ã©lÃ©ments, ce temps est presque imperceptible. Mais plus le tuple devient grand, plus la durÃ©e totale de lecture de tous ses Ã©lÃ©ments augmente et peut finir par devenir significative.

![permission_cat_personnes](https://github.com/Wextc/ESI_Bachelier/blob/main/DEV1/Laboratoire/TD10/td10.md/img/temps_acces.png)
