# Les tuples - ()

Un tuple est une structure de donn√©es en Python qui permet de regrouper plusieurs valeurs sous un m√™me nom. Chaque valeur peut √™tre consult√©e √† l‚Äôaide d‚Äôun indice, c‚Äôest-√†-dire un num√©ro qui indique sa position dans le tuple. Comme pour les listes, l‚Äôindice du premier √©l√©ment est toujours 0. La particularit√© du tuple est qu‚Äôil est immuable : une fois cr√©√©, son contenu ne peut plus √™tre modifi√©.

Pour cr√©er un tuple, on peut utiliser des parenth√®ses, comme dans (1, 2, 3, 4, 5), ou bien la fonction tuple(), par exemple tuple(range(10_000_000)). Dans le premier cas, le tuple contient les valeurs 1 √† 5, accessibles directement par leur indice : tuple_1[0] vaut 1, tuple_1[3] vaut 4, etc. Dans le second cas, le tuple contient une suite de valeurs allant de 0 √† 9 999 999, et l‚Äôacc√®s se fait de la m√™me mani√®re : tuple_2[1_000_000] renvoie 1 000 000.

Il est √©galement possible d‚Äô√©crire des nombres de grande taille en s√©parant les chiffres avec des caract√®res underscore (\_) afin de rendre le code plus lisible. Par exemple, 10_000_000 est strictement √©quivalent √† 10000000. Python ignore ces soulignements lors de l‚Äôinterpr√©tation du nombre, mais l‚Äô√©criture est plus claire pour l‚Äôhumain.

Exemples :

```
tuple_1 = (1, 2, 3, 4, 5)

tuple_2 = tuple(range(10_000_000))

```

<b>Voici toutes les m√©thodes qui s'applique aux tuples.</b>

<b> M√©thodes de tuple (Python)</b>

üîπ M√©thodes d‚Äôinstance

| M√©thode                  | Description                         |
| ------------------------ | ----------------------------------- |
| `__add__(value)`         | Retourne `self + value`             |
| `__contains__(key)`      | V√©rifie si `key` est dans le tuple  |
| `__eq__(value)`          | `self == value`                     |
| `__ge__(value)`          | `self >= value`                     |
| `__getattribute__(name)` | R√©cup√®re un attribut                |
| `__getitem__(key)`       | Acc√®s par index ou slice            |
| `__getnewargs__()`       | Utilis√© en interne pour le pickling |
| `__gt__(value)`          | `self > value`                      |
| `__hash__()`             | Retourne le hash du tuple           |
| `__iter__()`             | Renvoie un it√©rateur sur le tuple   |
| `__le__(value)`          | `self <= value`                     |
| `__len__()`              | Longueur du tuple                   |
| `__lt__(value)`          | `self < value`                      |
| `__mul__(value)`         | `self * value` (r√©p√©tition)         |
| `__ne__(value)`          | `self != value`                     |
| `__repr__()`             | Repr√©sentation officielle du tuple  |
| `__rmul__(value)`        | `value * self`                      |

<b>M√©thodes de classe</b>

| M√©thode                  | Description                                 |
| ------------------------ | ------------------------------------------- |
| `__class_getitem__(...)` | Supporte les annotations de type (PEP 585). |

<b>M√©thodes statiques</b>

| Sous-classe          |
| -------------------- |
| `asyncgen_hooks`     |
| `UnraisableHookArgs` |

<b>Exercice 1 : Maximum</b>

Soit le tuple suivant : (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84) √âcrivez une fonction ya_max qui recherche et retourne la valeur maximale de ce tuple. Affichez le r√©sultat de votre fonction de recherche de maximum et celui de la fonction built in max.

```

def ya_max(t):
    max_val = t[0]              # on part du premier √©l√©ment
    for val in t:               # on parcourt le tuple
        if val > max_val:       # si on trouve plus grand
            max_val = val
    return max_val


# Tuple donn√©
t = (-4, 12, -71, 33, 20, 32, 96, -22, -7, 70, 82, 62, 11, 72, -36, -16, 84)

# R√©sultats
print("Maximum trouv√© avec ya_max :", ya_max(t))
print("Maximum trouv√© avec max()  :", max(t))



```
